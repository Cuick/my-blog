+++
date = "2016-04-07T14:55:49+08:00"
title = "python-赋值、引用、拷贝、作用域"

tags = [ "python" ]
categories = [
  "python"
]

+++
<!--more-->

## 赋值 引用 浅复制 深复制

* python 中赋值语句总是建立对象的引用值，而不是复制对象。因此，python 变量更像是指针，而不是数据存储区域

        >>> values = [0, 1, 2]
        >>> values[1] = values
        >>> values
        [0, [...], 2]

    并非我预想de:

        [0, [0, 1, 2], 2]

* 要达到你所需要的效果，即得到 [0, [0, 1, 2], 2] 这个对象，你不能直接将 values[1] 指向 values 引用的对象本身，需要：

    所以你需要执行 

        values[1] = values[:]  #生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制

* values[:] 复制操作是所谓的「浅复制」(shallow copy)，当列表对象有嵌套的时候也会产生出乎意料的错误

        a = [0, [1, 2], 3]
        b = a[:]
        a[0] = 8
        a[1][1] = 9

    正确答案是 a 为 [8, [1, 9], 3]，b 为 [0, [1, 9], 3]
    b的第二个元组也变化了。

* 正确的复制嵌套元素的方法是进行「深复制」(deep copy)，方法是

        import copy

         a = [0, [1, 2], 3]
         b = copy.deepcopy(a)
         a[0] = 8
         a[1][1] = 9

## 引用 and 复制
* 没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能浅层复制。
* 字典 copy 方法，D.copy() 能够复制字典，但此法只能浅层复制
* 有些内置函数，例如 list，能够生成拷贝 list(L),浅复制
* copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy
* 对于不可变对象和可变对象来说，浅复制都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅复制只复制不可变对象（整数，实数，字符串等），对于可变对象，浅复制其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已。

## a+=b 与 a=a+b

    L = [1, 2]
    M = L
    L = L + [3, 4]
    print L, M
    print "-------------------"
    L = [1, 2]
    M = L
    L += [3, 4]
    print L, M

    [1, 2, 3, 4] [1, 2]
    -------------------
    [1, 2, 3, 4] [1, 2, 3, 4]

* 例子中两种操作结果不同
* x = x + y 定义一个x，合并x与y，赋值给x
* x += y 不生成新对象，只是把y添加到x内存块末尾，性能相比来要好
* x y 都为list时， +自动调用extend进行合并运算。

## python 从 2.x 到 3.x，语句变函数引发的变量作用域问题

    def test():
        a = False
        exec ("a = True")
        print ("a = ", a)
    test()
     
    b = False
    exec ("b = True")
    print ("b = ", b)

不同版本下结果分别为：

    2.x：
    a =  True
    b =  True
     
    3.x：
    a =  False
    b =  True

原因： 
在3.x版本中exec 由语句变成函数了，而在函数中变量默认都是局部的，也就是说 
你所见到的两个 a，是两个不同的变量，分别处于不同的命名空间中，而不会冲突。

兼容方案：

    def test():
        a = False
        ldict = locals()
        exec("a=True",globals(),ldict)
        a = ldict['a']
        print(a)
     
    test()
     
    b = False
    exec("b = True", globals())
    print("b = ", b)

## python 变量作用域及其陷阱

### 可变与不可变对象

* 不可变对象包括int，float，long，str，tuple等
* 可变对象包括list，set，dict等
* 不可变指的是值的不可变。对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收
* 不可变的类型可以计算hash值，可以作为字典的key
* 可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。

### 函数值传递

    def func_int(a):
        a += 4
      
    def func_list(a_list):
        a_list[0] = 4
      
    t = 0
    func_int(t)
    print t
    # output: 0
      
    t_list = [1, 2, 3]
    func_list(t_list)
    print t_list
    # output: [4, 2, 3]

* 引起上面现象的原因:对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。
* 在函数参数传递的时候，Python其实就是把参数里传入的变量对应的对象的引用依次赋值给对应的函数内部变量
* 例子中func_int中的局部变量"a"其实是全部变量"t"所指向对象的另一个引用，由于整数对象是不可变的，所以当func_int对变量"a"进行修改的时候，实际上是将局部变量"a"指向到了整数对象"1"。所以很明显，func_list修改的是一个可变的对象，局部变量"a"和全局变量"t_list"指向的还是同一个对象

### 局部变量 全局变量

例一

    s = 'foo'
    d = {'a':1}
    def f():
        s = 'bar'
        d['b'] = 2
    f()
    print s  # foo
    print d  # {'a': 1, 'b': 2}

* 在s = 'bar'这句中，它是“有歧义的“，因为它既可以是表示引用全局变量s，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global
* 在d['b']=2这句中，它是“明确的”，因为如果把d当作是局部变量的话，它会报KeyError，所以它只能是引用全局的d,故不需要多此一举显式声明global
* 止dict不需要global，所有”明确的“东西都不需要global
* int类型str类型之类的不可变对象，每一次操作就重建新的对象，他们只有一种修改方法，即x = y， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict/list/对象等可变对象，操作不会重建对象，可以通过dict['x']=y或list.append()之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。

例二

    list_a = []
    def a():
        list_a = [1]      ## 语句1
    a()
    print list_a    # []
    print "======================"
    list_b = []
    def b():
        list_b.append(1)    ## 语句2
    b()
    print list_b    # [1]
    print '======================='
    list_c = [1]
    def c():
        list_c[0] = 3      ## 语句3
    c()
    print list_c    # [3]

* 语句1有歧义所以python规定是定义了一个局部变量。
* 语句2与语句3没有歧义，是修改了全局变量，不然会是报错。

### 永远不要用可变的默认参数

    def foo(a, b, c=[]):
    # append to c
    # do some more stuff

这种写法，每次调用foo，用的都是同一个引用，同一个地方修改了c的值，其他地方跟着变。非常可怕！！！！！！！

要修改为：

    def foo(a, b, c=None):
        if c is None:
            c = []
        # append to c
        # do some more stuff


