+++
date = "2016-02-27T22:17:23+08:00"
title = "Twisted学习笔记"

+++

# 网络编程
* socket
* select
* poll
* epoll
* greenlet
* gevent
* gevent是基于协程的高性能Python网络库，相比Twisted、Stackless等，gevent使用libev事件循环，因此速度很快、性能很好，使用greenlet提供高层的同步API，因此非常轻量。
* http://www.elias.cn/Python/PyConcurrency
* http://blog.csdn.net/yueguanghaidao/




# Twisted

### twisted特点：
1. 在一个回调函数执行过程中，实际上Twisted的循环是被有效地阻塞在我们的代码上的。因此，因此我们应该确保回调函数不要浪费时间（尽快返回）。
2. 很多标准的Python方法没有办法转换为非阻塞方式。例如，os.system中的很多方法会在子进程完成前一直处于阻塞状态。这也就是它工作的方式。所以当你使用Twisted时，避开使用os.system。
3. 我们为Twisted程序写的API必须是异步的
4. 不能将同步与异步代码混合起来使用
5. 我们可以在自己的代码中写回调函数，正如Twisted做的那样
6. 并且，我们需要写处理错误信息的回调函数


### Reactor

* 一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能：

    1. 监视一系列与你I/O操作相关的文件描述符（description)
    2. 不停地向你汇报那些准备好I/O操作的文件描述符

* 一个设计优秀的reactor模式实现需要做到：
    1. 处理所有不同系统会出现的I/O事件  
    2. 提供优雅的抽象来帮助你在使用reactor时少花些心思去考虑它的存在
    3. 提供你可以在抽象层外（treactor实现）使用的公共协议实现。

* reactor特性  
    1. Twisted的reactor只有通过调用reactor.run()来启动。  
    2. reactor循环是在其开始的进程中运行，也就是运行在主进程中。  
    3. 一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。
    4. reactor循环并不会消耗任何CPU的资源。  
    5. 并不需要显式的创建reactor，只需要引入就OK了。  

*  使用twisted.internet.pollreactor中的系统调用来poll 来代替select方法  
    from twited.internet import pollreactor  
    pollreactor.install()  
    from twisted.internet import reactor  
    reactor.run()


### Transports
* 一个Twisted的Transport代表一个可以收发字节的单条连接。对于我们的诗歌下载客户端而言，就是对一条TCP连接的抽象。
* ransport抽象可以代表任何这样的连接并为其代表的连接处理具体的异步I/O操作细节。

### Protocols
* 一个具体的Twisted的Protocol的实现应该对应一个具体网络协议的实现，像FTP、IMAP或其它我们自己规定的协议。
* 每一个Twisted的Protocols类实例都为一个具体的连接提供协议解析。
* Protocol实例是存储协议状态与间断性接收并累积数据的地方（由于我们是通过异步I/O方式以任意大小来接收数据的）。
* Protocol实例如何得知它为哪条连接服务呢？如果你阅读IProtocol定义会发现一个makeConnection函数。这是一个回调函数，Twisted会在调用它时传递给其一个也是仅有的一个参数，即就是Transport实例。这个Transport实例就代表Protocol将要使用的连接。

### Protocol Factories
* 每个连接需要一个自己的Portocol
* Protocol Factories一个新的连接制定一个合适的协议
* Protocol Factory就是Factory模式的一个具体实现。
* buildProtocol方法在每次被调用时返回一个新Protocol实例。它就是Twisted用来为新连接创建新Protocol实例的方法。

### Failure
* 如果有异常出现的话，其能捕获Exception与跟踪栈。
* 将一个Failure对象付给回调函数，我们就可以为以后的调试保存跟踪栈的信息了。

<li> aaaaa

<table>
  <tr>
    <td>&</td>
    <td>&</td>
  </tr>
</table>

<a href="http://www.w3school.com.cn">This is a link</a>
